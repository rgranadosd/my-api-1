name: API Scoring

on:
  workflow_run:
    workflows: ["Importar"]          # ← Debe coincidir EXACTAMENTE con el name: del flujo padre
    types: [completed]

jobs:
  run-scoring:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest

    steps:
    # 1) Checkout del repositorio
    - name: Checkout repo
      uses: actions/checkout@v3

    # 2) Clonar el motor de scoring
    - name: Clone scoring engine
      run: git clone --depth 1 https://github.com/rgranadosd/api-scoring-engine.git scoring_engine

    # 3) Crear alias docker-compose si el runner sólo trae Compose v2
    - name: Enable docker-compose alias if needed
      run: |
        if ! command -v docker-compose &>/dev/null; then
          printf '#!/usr/bin/env bash\nexec docker compose "$@"\n' \
            | sudo tee /usr/local/bin/docker-compose >/dev/null
          sudo chmod +x /usr/local/bin/docker-compose
        fi

    # 4) Arrancar contenedor y esperar a que /health devuelva 200 OK
    - name: Start scoring engine
      working-directory: scoring_engine
      run: |
        docker-compose up --build -d
        echo "⏳ Waiting for /health 200..."
        for i in {1..30}; do
          curl -sf http://localhost:8088/health >/dev/null && { echo "✅ Ready"; break; }
          sleep 5
          [[ $i -eq 30 ]] && { echo "::error::Timeout"; docker-compose logs; exit 1; }
        done

    # 5) Localizar todas las especificaciones apis/**/api.yaml
    - name: Find api.yaml
      id: specs
      run: |
        mapfile -t SPEC_FILES < <(git ls-files 'apis/**/api.yaml')
        # Verificar si se encontraron archivos antes de continuar
        if [ ${#SPEC_FILES[@]} -eq 0 ]; then
          echo "::error::No se encontró ningún archivo api.yaml."
          exit 1
        fi
        { echo 'specs<<EOF'; printf '%s\n' "${SPEC_FILES[@]}"; echo 'EOF'; } >> "$GITHUB_OUTPUT"

    # 6) Calcular scoring y generar Job Summary coloreado
    - name: Run scoring & build summary
      run: |
        # Leer las especificaciones encontradas en el paso anterior
        mapfile -t SPECS <<<"${{ steps.specs.outputs.specs }}"
        mkdir -p scores # Asegurarse de que el directorio 'scores' existe

        # Cabecera del resumen que se mostrará en el Job Summary
        {
          echo "## Resultados de calidad de las APIs"
          echo
          echo "| API | Módulo | Nota |"
          echo "|-----|--------|------|"
        } >> "$GITHUB_STEP_SUMMARY"

        # Función auxiliar de shell para colorear celdas según la nota
        color () {
          [[ "$1" =~ ^([A]|B($|\+)) ]] \
            && printf "<span style='color:#22863a;font-weight:bold;'>%s</span>" "$1" \
            || printf "<span style='color:#d91e18;font-weight:bold;'>%s</span>" "$1"
        }

        # Iterar sobre cada archivo de especificación api.yaml encontrado
        for spec in "${SPECS[@]}"; do
          # Extraer el nombre de la API y la versión del path del archivo
          api=$(basename "$(dirname "$(dirname "$spec")")")
          ver=$(basename "$(dirname "$spec")")
          out="scores/${api}_${ver}.json" # Definir el nombre del archivo de salida del scoring

          echo "⏩ Scoring $spec → $out" # Imprimir progreso

          # Ejecutar la llamada al motor de scoring usando curl
          curl --fail -s \
            -X POST \
            -F "file=@${spec};type=text/yaml" \
            -F "apiProtocol=REST" \
            http://localhost:8088/apifirst/v1/apis/score-file \
            -o "$out" # Guardar la respuesta (el JSON del scoring) en un archivo

          # ─── Procesar y añadir la Fila Overall al resumen ───
          # Usar jq para extraer la nota general, manejando posibles nombres de campo diferentes
          overall=$(jq -r '.overallGrade // .grade // "?"' "$out")
          # Añadir la fila Overall a la tabla del resumen, coloreando la nota
          echo "| ${api} ${ver} | **Overall** | $(color "$overall") |" >> "$GITHUB_STEP_SUMMARY"

          # ─── Recorrer .modules (array u objeto) y añadirlos al resumen ───
          # Usar jq para extraer los módulos y sus notas.
          # Este es el comando jq corregido para evitar problemas de comillado.
          jq -r '
            # Define una función para procesar módulos si .modules es un array
            def pairs_from_array:
              map({ # Mapea cada elemento del array a un objeto temporal
                name: (.name // .module // .id), # Encuentra el nombre/id del módulo
                grade: (.grade // .score // .value // .rating // "?") # Encuentra la nota/valor del módulo
              }) | map("\(.name)\t\(.grade)"); # Formatea los objetos a "nombre\tnota"

            # Define una función para procesar módulos si .modules es un objeto
            def pairs_from_object:
              to_entries | map({ # Convierte el objeto en un array de [key, value]
                key: .key, # La clave es el nombre del módulo
                value: (.value // "?") # El valor es la nota del módulo
              }) | map("\(.key)\t\(.value)"); # Formatea los objetos a "nombre\tnota"

            # Selecciona .modules, si no existe usa un objeto vacío {}
            (.modules // {}) as $m
            # Verifica si $m es un array o un objeto y aplica la función correspondiente
            |  if ($m|type) == "array"  then $m | pairs_from_array[] # Si es array, procesa como array
               elif ($m|type) == "object" then $m | pairs_from_object[] # Si es objeto, procesa como objeto
               else empty end # Si no es ni array ni objeto, no produce salida
          ' "$out" | while IFS=$'\t' read -r mod grade; do
              # Por cada par "módulo nota" encontrado por jq, añadir una fila a la tabla del resumen
              echo "| ${api} ${ver} | ${mod} | $(color "$grade") |" >> "$GITHUB_STEP_SUMMARY"
          done
        done

    # 7) Subir todos los JSON generados como un artefacto del workflow
    - name: Upload scores
      uses: actions/upload-artifact@v4
      with:
        name: api-scores # Nombre del artefacto
        path: scores/ # Directorio a comprimir y subir

    # 8) Apagar y limpiar el contenedor de Docker (Este paso siempre se ejecuta, incluso si fallan los anteriores)
    - name: Tear-down
      if: always() # Garantiza que este paso se ejecute
      working-directory: scoring_engine # Ejecutar desde el directorio del motor de scoring
      run: docker-compose down # Comando para detener y eliminar los contenedores y redes definidos en docker-compose.yml